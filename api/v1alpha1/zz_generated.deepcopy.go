// Code generated by hand for the skeleton project; normally produced by controller-gen.
//
// This file exists to make the project compile-ready without requiring code generation.

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ModuleManifest) DeepCopyInto(out *ModuleManifest) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ModuleManifest.
func (in *ModuleManifest) DeepCopy() *ModuleManifest {
	if in == nil {
		return nil
	}
	out := new(ModuleManifest)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ModuleManifest) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ModuleManifestSpec) DeepCopyInto(out *ModuleManifestSpec) {
	*out = *in
	out.Module = in.Module
	if in.Provides != nil {
		out.Provides = make([]ProvidedCapability, len(in.Provides))
		copy(out.Provides, in.Provides)
	}
	if in.Requires != nil {
		out.Requires = make([]RequiredCapability, len(in.Requires))
		copy(out.Requires, in.Requires)
	}
	out.Scaling = in.Scaling
	in.Scheduling.DeepCopyInto(&out.Scheduling)
	if in.ExtraSpec != nil {
		out.ExtraSpec = make(map[string]any, len(in.ExtraSpec))
		for k, v := range in.ExtraSpec {
			out.ExtraSpec[k] = v
		}
	}
}

// DeepCopyInto copies the receiver into out.
func (in *ModuleManifestList) DeepCopyInto(out *ModuleManifestList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ModuleManifest, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

// DeepCopy creates a new ModuleManifestList.
func (in *ModuleManifestList) DeepCopy() *ModuleManifestList {
	if in == nil {
		return nil
	}
	out := new(ModuleManifestList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject creates a new runtime.Object.
func (in *ModuleManifestList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *GameDefinition) DeepCopyInto(out *GameDefinition) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

func (in *GameDefinition) DeepCopy() *GameDefinition {
	if in == nil {
		return nil
	}
	out := new(GameDefinition)
	in.DeepCopyInto(out)
	return out
}

func (in *GameDefinition) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *GameDefinitionSpec) DeepCopyInto(out *GameDefinitionSpec) {
	*out = *in
	if in.Modules != nil {
		out.Modules = make([]GameModuleRef, len(in.Modules))
		copy(out.Modules, in.Modules)
	}
	if in.Colocation != nil {
		out.Colocation = make([]ColocationGroup, len(in.Colocation))
		for i := range in.Colocation {
			in.Colocation[i].DeepCopyInto(&out.Colocation[i])
		}
	}
	if in.Defaults != nil {
		out.Defaults = make(map[string]string, len(in.Defaults))
		for k, v := range in.Defaults {
			out.Defaults[k] = v
		}
	}
}

func (in *GameDefinitionList) DeepCopyInto(out *GameDefinitionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]GameDefinition, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *GameDefinitionList) DeepCopy() *GameDefinitionList {
	if in == nil {
		return nil
	}
	out := new(GameDefinitionList)
	in.DeepCopyInto(out)
	return out
}

func (in *GameDefinitionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldInstance) DeepCopyInto(out *WorldInstance) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
	if in.Status.Conditions != nil {
		out.Status.Conditions = make([]metav1.Condition, len(in.Status.Conditions))
		copy(out.Status.Conditions, in.Status.Conditions)
	}
}

func (in *WorldInstance) DeepCopy() *WorldInstance {
	if in == nil {
		return nil
	}
	out := new(WorldInstance)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldInstance) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldInstanceList) DeepCopyInto(out *WorldInstanceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]WorldInstance, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *WorldInstanceList) DeepCopy() *WorldInstanceList {
	if in == nil {
		return nil
	}
	out := new(WorldInstanceList)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldInstanceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *CapabilityBinding) DeepCopyInto(out *CapabilityBinding) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *CapabilityBinding) DeepCopy() *CapabilityBinding {
	if in == nil {
		return nil
	}
	out := new(CapabilityBinding)
	in.DeepCopyInto(out)
	return out
}

func (in *CapabilityBinding) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *CapabilityBindingSpec) DeepCopyInto(out *CapabilityBindingSpec) {
	*out = *in
	if in.WorldRef != nil {
		out.WorldRef = &WorldRef{Name: in.WorldRef.Name}
	}
	out.Consumer = in.Consumer
	if in.Consumer.Requirement != nil {
		out.Consumer.Requirement = new(RequirementHint)
		*out.Consumer.Requirement = *in.Consumer.Requirement
		if in.Consumer.Requirement.RequiredFeatures != nil {
			out.Consumer.Requirement.RequiredFeatures = make([]string, len(in.Consumer.Requirement.RequiredFeatures))
			copy(out.Consumer.Requirement.RequiredFeatures, in.Consumer.Requirement.RequiredFeatures)
		}
		if in.Consumer.Requirement.PreferredFeatures != nil {
			out.Consumer.Requirement.PreferredFeatures = make([]string, len(in.Consumer.Requirement.PreferredFeatures))
			copy(out.Consumer.Requirement.PreferredFeatures, in.Consumer.Requirement.PreferredFeatures)
		}
	}
	out.Provider = in.Provider
}

func (in *CapabilityBindingStatus) DeepCopyInto(out *CapabilityBindingStatus) {
	*out = *in
	if in.Provider != nil {
		out.Provider = new(ProviderStatus)
		in.Provider.DeepCopyInto(out.Provider)
	}
	if in.LastResolvedTime != nil {
		out.LastResolvedTime = in.LastResolvedTime.DeepCopy()
	}
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		copy(out.Conditions, in.Conditions)
	}
}

func (in *ProviderStatus) DeepCopyInto(out *ProviderStatus) {
	*out = *in
	if in.Endpoint != nil {
		out.Endpoint = &EndpointRef{
			Type:  in.Endpoint.Type,
			Value: in.Endpoint.Value,
			Port:  in.Endpoint.Port,
		}
	}
}

func (in *CapabilityBindingList) DeepCopyInto(out *CapabilityBindingList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]CapabilityBinding, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *CapabilityBindingList) DeepCopy() *CapabilityBindingList {
	if in == nil {
		return nil
	}
	out := new(CapabilityBindingList)
	in.DeepCopyInto(out)
	return out
}

func (in *CapabilityBindingList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldShard) DeepCopyInto(out *WorldShard) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

func (in *WorldShard) DeepCopy() *WorldShard {
	if in == nil {
		return nil
	}
	out := new(WorldShard)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldShard) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldShardList) DeepCopyInto(out *WorldShardList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]WorldShard, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *WorldShardList) DeepCopy() *WorldShardList {
	if in == nil {
		return nil
	}
	out := new(WorldShardList)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldShardList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldStorageClaim) DeepCopyInto(out *WorldStorageClaim) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

func (in *WorldStorageClaim) DeepCopy() *WorldStorageClaim {
	if in == nil {
		return nil
	}
	out := new(WorldStorageClaim)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldStorageClaim) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldStorageClaimSpec) DeepCopyInto(out *WorldStorageClaimSpec) {
	*out = *in
	out.WorldRef = in.WorldRef
	if in.ShardRef != nil {
		out.ShardRef = &ObjectRef{Name: in.ShardRef.Name}
	}
	if in.AccessModes != nil {
		out.AccessModes = make([]string, len(in.AccessModes))
		copy(out.AccessModes, in.AccessModes)
	}
}

func (in *WorldStorageClaimList) DeepCopyInto(out *WorldStorageClaimList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]WorldStorageClaim, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *WorldStorageClaimList) DeepCopy() *WorldStorageClaimList {
	if in == nil {
		return nil
	}
	out := new(WorldStorageClaimList)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldStorageClaimList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ModuleScheduling) DeepCopyInto(out *ModuleScheduling) {
	*out = *in
	if in.Affinity != nil {
		in.Affinity = in.Affinity.DeepCopy()
	}
	if in.Tolerations != nil {
		out.Tolerations = make([]corev1.Toleration, len(in.Tolerations))
		for i := range in.Tolerations {
			in.Tolerations[i].DeepCopyInto(&out.Tolerations[i])
		}
	}
	if in.NodeSelector != nil {
		out.NodeSelector = make(map[string]string, len(in.NodeSelector))
		for k, v := range in.NodeSelector {
			out.NodeSelector[k] = v
		}
	}
}

func (in *ColocationGroup) DeepCopyInto(out *ColocationGroup) {
	*out = *in
	if in.Modules != nil {
		out.Modules = make([]string, len(in.Modules))
		copy(out.Modules, in.Modules)
	}
}
