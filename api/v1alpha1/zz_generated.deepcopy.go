// Code generated by hand for the skeleton project; normally produced by controller-gen.
//
// This file exists to make the project compile-ready without requiring code generation.

package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ModuleManifest) DeepCopyInto(out *ModuleManifest) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ModuleManifest.
func (in *ModuleManifest) DeepCopy() *ModuleManifest {
	if in == nil {
		return nil
	}
	out := new(ModuleManifest)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ModuleManifest) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ModuleManifestSpec) DeepCopyInto(out *ModuleManifestSpec) {
	*out = *in
	out.Module = in.Module
	if in.Provides != nil {
		out.Provides = make([]ProvidedCapability, len(in.Provides))
		copy(out.Provides, in.Provides)
	}
	if in.Requires != nil {
		out.Requires = make([]RequiredCapability, len(in.Requires))
		copy(out.Requires, in.Requires)
	}
	out.Scaling = in.Scaling
	if in.ExtraSpec != nil {
		out.ExtraSpec = make(map[string]any, len(in.ExtraSpec))
		for k, v := range in.ExtraSpec {
			out.ExtraSpec[k] = v
		}
	}
}

// DeepCopyInto copies the receiver into out.
func (in *ModuleManifestList) DeepCopyInto(out *ModuleManifestList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ModuleManifest, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

// DeepCopy creates a new ModuleManifestList.
func (in *ModuleManifestList) DeepCopy() *ModuleManifestList {
	if in == nil {
		return nil
	}
	out := new(ModuleManifestList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject creates a new runtime.Object.
func (in *ModuleManifestList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *GameDefinition) DeepCopyInto(out *GameDefinition) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

func (in *GameDefinition) DeepCopy() *GameDefinition {
	if in == nil {
		return nil
	}
	out := new(GameDefinition)
	in.DeepCopyInto(out)
	return out
}

func (in *GameDefinition) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *GameDefinitionSpec) DeepCopyInto(out *GameDefinitionSpec) {
	*out = *in
	if in.Modules != nil {
		out.Modules = make([]GameModuleRef, len(in.Modules))
		copy(out.Modules, in.Modules)
	}
	if in.Defaults != nil {
		out.Defaults = make(map[string]string, len(in.Defaults))
		for k, v := range in.Defaults {
			out.Defaults[k] = v
		}
	}
}

func (in *GameDefinitionList) DeepCopyInto(out *GameDefinitionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]GameDefinition, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *GameDefinitionList) DeepCopy() *GameDefinitionList {
	if in == nil {
		return nil
	}
	out := new(GameDefinitionList)
	in.DeepCopyInto(out)
	return out
}

func (in *GameDefinitionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldInstance) DeepCopyInto(out *WorldInstance) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

func (in *WorldInstance) DeepCopy() *WorldInstance {
	if in == nil {
		return nil
	}
	out := new(WorldInstance)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldInstance) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *WorldInstanceList) DeepCopyInto(out *WorldInstanceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]WorldInstance, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *WorldInstanceList) DeepCopy() *WorldInstanceList {
	if in == nil {
		return nil
	}
	out := new(WorldInstanceList)
	in.DeepCopyInto(out)
	return out
}

func (in *WorldInstanceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *CapabilityBinding) DeepCopyInto(out *CapabilityBinding) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *CapabilityBinding) DeepCopy() *CapabilityBinding {
	if in == nil {
		return nil
	}
	out := new(CapabilityBinding)
	in.DeepCopyInto(out)
	return out
}

func (in *CapabilityBinding) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *CapabilityBindingSpec) DeepCopyInto(out *CapabilityBindingSpec) {
	*out = *in
	if in.WorldRef != nil {
		out.WorldRef = &WorldRef{Name: in.WorldRef.Name}
	}
	out.Consumer = in.Consumer
	if in.Consumer.Requirement != nil {
		out.Consumer.Requirement = new(RequirementHint)
		*out.Consumer.Requirement = *in.Consumer.Requirement
		if in.Consumer.Requirement.RequiredFeatures != nil {
			out.Consumer.Requirement.RequiredFeatures = make([]string, len(in.Consumer.Requirement.RequiredFeatures))
			copy(out.Consumer.Requirement.RequiredFeatures, in.Consumer.Requirement.RequiredFeatures)
		}
		if in.Consumer.Requirement.PreferredFeatures != nil {
			out.Consumer.Requirement.PreferredFeatures = make([]string, len(in.Consumer.Requirement.PreferredFeatures))
			copy(out.Consumer.Requirement.PreferredFeatures, in.Consumer.Requirement.PreferredFeatures)
		}
	}
	out.Provider = in.Provider
}

func (in *CapabilityBindingStatus) DeepCopyInto(out *CapabilityBindingStatus) {
	*out = *in
	if in.Provider != nil {
		out.Provider = new(ProviderStatus)
		in.Provider.DeepCopyInto(out.Provider)
	}
}

func (in *ProviderStatus) DeepCopyInto(out *ProviderStatus) {
	*out = *in
	if in.Endpoint != nil {
		out.Endpoint = &EndpointRef{
			Type:  in.Endpoint.Type,
			Value: in.Endpoint.Value,
			Port:  in.Endpoint.Port,
		}
	}
}

func (in *CapabilityBindingList) DeepCopyInto(out *CapabilityBindingList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]CapabilityBinding, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *CapabilityBindingList) DeepCopy() *CapabilityBindingList {
	if in == nil {
		return nil
	}
	out := new(CapabilityBindingList)
	in.DeepCopyInto(out)
	return out
}

func (in *CapabilityBindingList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
